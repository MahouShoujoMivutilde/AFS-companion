## Скрипт-компаньон для [Advanced FrameServer](http://advancedfs.sourceforge.net/)
Рассчитан на работу вместе __[AviSynth](http://avisynth.nl/index.php/Main_Page)__ и __[FFmpeg](http://ffmpeg.zeranoe.com/builds/)__ 32bit (из-за AviSynth только 32, увы), который, разумеется, должен быть добавлен в __PATH__. 

Будет работать на `python 3.3+`. 

_exe-версию можно найти [тут](https://github.com/MahouShoujoMivutilde/AFS-companion/releases)._

Сам же скрипт предполагается добавить в автозапуск.

Написано для личного использования, ибо __libx264 [выигрывает по качеству](https://imgur.com/a/uLmJW) у mainconcept h.264__ в Adobe PP Pro при аналогичном битрейте. Последний же, более того, имеет весьма скудный набор опций, среди которых нет возможности задать RF, который может быть полезен, когда не знаешь, насколько хорошо картинка будет ужиматься при конкретном битрейте.

~~Разумеется, в сравнении выше недостаточный для однопроходного кодирования битрейт этого весьма насыщенного эффектами видео был выбран намеренно, чтобы продемонстировать разницу более наглядно. На каком-нибудь 10М 2-pass всё было бы далеко не настолько печально. Но тем не менее~~...

..._Однако_, кодирует на ~30%+ дольше. Увы, за хорошее сжатие приходится платить...

Предполагает, что в настройках AFS выбраны параметры `stop serving when idle`, и `idle timeout`  __установлен на 10 секунд__ - минимальное доступное время:

![здесь был скрин настроек, но ты и так справишься, я верю в тебя ^__^](https://i.imgur.com/XT3eZkE.png)

Временный __AVI-файл__ из AFS дефолтно __должен быть сохранен в__ `C:\ENCODE\`, оттуда скрипт его автоматически подхватит, начиная кодирование с найденными параметрами или своими дефолтными. Впрочем, базовые параметры можно легко изменить буквально в первых строчках скрипта.

По-умолчанию __работает в фоне, открывая консоль только во время кодирования__ ради вывода прогресса, но можно и постоянно держать открытым, для этого нужно просто сменить расширение с `.pyw` на `.py`.

__Поддерживает очередь__, собственно, ради этого и нужен таймаут.

__Кстати, о других опциональных параметрах__ - некоторые настройки можно задавать близким к FFmpeg синтаксисом через имя выходного файла:
* `my file name scale=w,h.avi` в итоге даст масштаб до ширины `w` и высоты `h` аналогично опции FFmpeg `-vf scale=w:h -sws_flags lanczos`:
* * так, например, `scale=-2,1080` отмасштабирует до 1080px по высоте, сохраняя при этом делимость на 2 ширины (нужно для кодека x264)
* * умеет только в числа, ~~в будущем, быть может, добавлю `iw` и `ih`, хотя, учитывая контекст использования, пока не вижу смысла~~...
* `my file name -an.avi` уберет аудио - _сделано специально для mp4-анимаций telegram_, ~~ради которого, собственно, это добро и написано~~. Без неё кодирует AAC 576k.
* `my file name -crf 20.avi` даст кодирование с RF = 20, принимает значение в пределах [0-51], при отсутствии/неверном значении кодируется с RF=18:
* * ![0 lossless >>> 18 better >>> 23 x264 default >>> 28 worse >>> 51 worst](https://i.imgur.com/oeuko1s.png)

__Параметры можно комбинировать__, разумеется.

Протестировано и успешно работает на
* `Adobe Premiere Pro CC 2017` и `Adobe Media Encoder CC 2017`
* `python 3.6.1`
* `AviSynth 2.6.0.6`
* `FFmpeg 3.2.4 win32 shared`

_p.s.
Из-за AviSynth боится всяких кандзи и прочего юникода в названиях файлов. Увы._